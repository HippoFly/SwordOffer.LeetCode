package com.so.leetcode;

/**
 * 62. 不同路径
 * <p>
 * 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
 * <p>
 * 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
 * <p>
 * 问总共有多少条不同的路径？
 *
 * @author FlyHippo
 * @version 1.0
 * @created 2025-06-03 16:35
 * @tag
 * @link <a href=""></a>
 **/
public class Q62_UniquePaths {
        /*
    动态规划
    思路：定义一个二维数组 dp[i][j]，表示从起点到位置 (i, j) 的不同路径数。由于机器人只能向右或向下移动，
    状态转移方程为： $$ dp[i][j] = dp[i-1][j] + dp[i][j-1] $$ 初始化第一行和第一列的所有值为1，因为机器人只能一直向右或一直向下到达这些位置。
    * */

    /**
     * 计算从起点到终点的不同路径数
     *
     * @param m 网格的列数
     * @param n 网格的行数
     * @return 从起点到终点的不同路径数
     */
    public int uniquePaths(int m, int n) {
        // 创建一个二维数组来存储到达每个位置的路径数
        int[][] dp = new int[m][n];

        // 初始化第一列，由于机器人只能向下移动，到达这些位置的路径数只能为1
        for (int i = 0; i < m; i++) {
            dp[i][0] = 1;
        }
        // 初始化第一行，由于机器人只能向右移动，到达这些位置的路径数只能为1
        for (int j = 0; j < n; j++) {
            dp[0][j] = 1;
        }

        // 从第二行第二列开始填充dp数组，每个位置的路径数是其上方和左方位置路径数之和
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }

        // 返回到达终点的不同路径数
        return dp[m - 1][n - 1];
    }

}
